from datetime import datetime
from typing import List

from models import Episode, Category, Newsletter


# Human-readable category names
CATEGORY_NAMES = {
    Category.TECH_STARTUPS: "Tech & Startups",
    Category.BUSINESS_FINANCE: "Business & Finance",
    Category.NEWS_CURRENT_EVENTS: "News & Current Events",
    Category.PHILOSOPHY: "Philosophy",
    Category.LIFESTYLE_PERSONAL_GROWTH: "Lifestyle & Personal Growth",
    Category.CAREER_DEVELOPMENT: "Career Development",
    Category.HEALTH_LONGEVITY: "Health & Longevity",
    Category.FITNESS_WEIGHT_TRAINING: "Fitness & Weight Training",
    Category.SLEEP_MANAGEMENT: "Sleep Management",
    Category.UNCATEGORIZED: "Other Podcasts",
}

# Category display order
CATEGORY_ORDER = [
    Category.TECH_STARTUPS,
    Category.HEALTH_LONGEVITY,
    Category.FITNESS_WEIGHT_TRAINING,
    Category.SLEEP_MANAGEMENT,
    Category.LIFESTYLE_PERSONAL_GROWTH,
    Category.CAREER_DEVELOPMENT,
    Category.PHILOSOPHY,
    Category.UNCATEGORIZED,
]

# Category summaries
CATEGORY_SUMMARIES = {
    Category.TECH_STARTUPS: "The latest on AI breakthroughs, startup strategies, and emerging technologies shaping our digital future.",
    Category.BUSINESS_FINANCE: "Insights on markets, investing strategies, and business leadership from top financial minds.",
    Category.NEWS_CURRENT_EVENTS: "Stay informed with analysis of today's most important stories and global developments.",
    Category.PHILOSOPHY: "Deep explorations of meaning, ethics, and the big questions that shape how we live.",
    Category.LIFESTYLE_PERSONAL_GROWTH: "Practical wisdom for building better habits, relationships, and a more fulfilling life.",
    Category.CAREER_DEVELOPMENT: "Expert advice on advancing your career, negotiating, and thriving in the modern workplace.",
    Category.HEALTH_LONGEVITY: "Science-backed insights on nutrition, longevity, and optimizing your physical and mental health.",
    Category.FITNESS_WEIGHT_TRAINING: "Training tips, workout strategies, and performance optimization for fitness enthusiasts.",
    Category.SLEEP_MANAGEMENT: "Research and practical tips for better sleep, recovery, and managing your energy levels.",
    Category.UNCATEGORIZED: "Fascinating conversations and stories that don't fit neatly into one box.",
}

# Max episodes to show per category
MAX_EPISODES_PER_CATEGORY_DISPLAY = 2


def generate_newsletter(newsletter: Newsletter) -> str:
    """Generate markdown content for a newsletter."""
    lines = []

    # Header
    date_str = newsletter.date.strftime("%B %d, %Y")
    lines.append(f"# Podcast Inspiration - {date_str}")
    lines.append("")
    lines.append(f"*{newsletter.total_episodes} episodes curated for you*")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Table of contents
    lines.append("## Contents")
    lines.append("")
    for category in CATEGORY_ORDER:
        if category in newsletter.episodes_by_category:
            count = len(newsletter.episodes_by_category[category])
            anchor = CATEGORY_NAMES[category].lower().replace(" & ", "-").replace(" ", "-")
            lines.append(f"- [{CATEGORY_NAMES[category]}](#{anchor}) ({count})")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Episodes by category
    for category in CATEGORY_ORDER:
        if category not in newsletter.episodes_by_category:
            continue

        episodes = newsletter.episodes_by_category[category]
        if not episodes:
            continue

        lines.append(f"## {CATEGORY_NAMES[category]}")
        lines.append("")

        # Add category summary
        if category in CATEGORY_SUMMARIES:
            lines.append(f"*{CATEGORY_SUMMARIES[category]}*")
            lines.append("")

        # Limit to MAX_EPISODES_PER_CATEGORY_DISPLAY episodes
        for episode in episodes[:MAX_EPISODES_PER_CATEGORY_DISPLAY]:
            lines.extend(_format_episode(episode))
            lines.append("")

        lines.append("---")
        lines.append("")

    # Footer
    lines.append("*Generated by Podcast Inspiration*")
    lines.append("")

    return "\n".join(lines)


def _format_episode(episode: Episode) -> List[str]:
    """Format a single episode as markdown."""
    lines = []

    # Title with link if available
    if episode.episode_url:
        lines.append(f"### [{episode.title}]({episode.episode_url})")
    else:
        lines.append(f"### {episode.title}")

    # Podcast info
    podcast_info = f"**{episode.podcast_title}**"
    if episode.podcast_author:
        podcast_info += f" by {episode.podcast_author}"
    lines.append(podcast_info)

    # Metadata line
    meta_parts = []
    if episode.published_at:
        meta_parts.append(episode.published_at.strftime("%b %d, %Y"))
    if episode.duration_seconds:
        meta_parts.append(episode.duration_formatted)
    if meta_parts:
        lines.append(f"*{' | '.join(meta_parts)}*")

    lines.append("")

    # Description
    if episode.description:
        # Limit description length for readability
        desc = episode.description
        if len(desc) > 300:
            desc = desc[:297] + "..."
        lines.append(desc)

    # AI Summary (if available)
    if episode.summary:
        lines.append("")
        lines.append("**Summary:**")
        lines.append(episode.summary)

    return lines


def generate_email_html(newsletter: Newsletter) -> str:
    """Generate HTML content for email delivery."""
    date_str = newsletter.date.strftime("%B %d, %Y")

    html_parts = [
        "<!DOCTYPE html>",
        '<html lang="en">',
        "<head>",
        '<meta charset="UTF-8">',
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
        f"<title>Podcast Inspiration - {date_str}</title>",
        "<style>",
        "body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 700px; margin: 0 auto; padding: 20px; color: #333; }",
        "h1 { color: #1a1a2e; border-bottom: 2px solid #4a90d9; padding-bottom: 10px; }",
        "h2 { color: #4a90d9; margin-top: 30px; }",
        "h3 { margin-bottom: 5px; }",
        "h3 a { color: #1a1a2e; text-decoration: none; }",
        "h3 a:hover { color: #4a90d9; }",
        ".episode { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; }",
        ".podcast-name { color: #666; font-weight: 600; }",
        ".meta { color: #888; font-size: 0.9em; margin: 5px 0; }",
        ".description { margin-top: 10px; }",
        ".footer { margin-top: 40px; text-align: center; color: #888; font-size: 0.9em; }",
        "</style>",
        "</head>",
        "<body>",
        f"<h1>Podcast Inspiration</h1>",
        f"<p><em>{date_str} - {newsletter.total_episodes} episodes curated for you</em></p>",
    ]

    for category in CATEGORY_ORDER:
        if category not in newsletter.episodes_by_category:
            continue

        episodes = newsletter.episodes_by_category[category]
        if not episodes:
            continue

        html_parts.append(f"<h2>{CATEGORY_NAMES[category]}</h2>")

        # Add category summary
        if category in CATEGORY_SUMMARIES:
            html_parts.append(f"<p><em>{CATEGORY_SUMMARIES[category]}</em></p>")

        # Limit to MAX_EPISODES_PER_CATEGORY_DISPLAY episodes
        for episode in episodes[:MAX_EPISODES_PER_CATEGORY_DISPLAY]:
            html_parts.append('<div class="episode">')

            # Title
            if episode.episode_url:
                html_parts.append(f'<h3><a href="{episode.episode_url}">{episode.title}</a></h3>')
            else:
                html_parts.append(f"<h3>{episode.title}</h3>")

            # Podcast info
            html_parts.append(f'<div class="podcast-name">{episode.podcast_title}</div>')

            # Meta
            meta_parts = []
            if episode.published_at:
                meta_parts.append(episode.published_at.strftime("%b %d, %Y"))
            if episode.duration_seconds:
                meta_parts.append(episode.duration_formatted)
            if meta_parts:
                html_parts.append(f'<div class="meta">{" | ".join(meta_parts)}</div>')

            # Description
            if episode.description:
                desc = episode.description[:300] + "..." if len(episode.description) > 300 else episode.description
                html_parts.append(f'<div class="description">{desc}</div>')

            html_parts.append("</div>")

    html_parts.extend([
        '<div class="footer">',
        "<p>Generated by Podcast Inspiration</p>",
        "</div>",
        "</body>",
        "</html>",
    ])

    return "\n".join(html_parts)
